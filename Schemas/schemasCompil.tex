\documentclass[a4paper, 11pt]{report}

\addtolength{\hoffset}{-1cm}
\addtolength{\textwidth}{2cm}

\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}

\usepackage{multicol}


\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\lstnewenvironment{OCaml}
                  {\lstset{
                      language=[Objective]Caml,
                      breaklines=true,
                      showstringspaces=false,
                      commentstyle=\color{purple},
                      stringstyle=\color{red},
                      identifierstyle=\ttfamily,
                      keywordstyle=\color{blue},
                      basicstyle=\footnotesize,
                      %xleftmargin=0.08\textwidth
                    }
                  }
                  {}
\lstdefinelanguage{idlgrammar}{
  morekeywords={package,abstract,extends,class,implements,static,final,<ini>,interface,callback,array,[,],name,void,boolean,byte,char,short,int,long,float,double,string},
  opt={<,>},
  typ={file,idlpackage,decl,idlclass,class_elt,idlinterface,interface_elt,args,arg,attributes,attribute,type,basetype,object,qname,idlname}
}
 \lstnewenvironment{idl}
                  {\lstset{
                      language=idlgrammar,
                      breaklines=true,
                      showstringspaces=false,
                      optstyle=\color{red},
                      typstyle={\color{purple},
                      keywordstyle=\color{blue},
                      identifierstyle=\ttfamily,
                      basicstyle=\footnotesize,
                      %xleftmargin=0.08\textwidth
                    }
                  }
                  {}        
\begin{document}

\chapter{}

Béatrice CARRE

\section*{Introduction}

La génération de code se fait en plusieurs passes :
\begin{itemize}
\item analyse lexicale et analyse syntaxique de l' idl donnant un
  ast de type Idl.file.
\item vérification des types de l'ast, donnant un nouvel ast de type
  CIdl.file.
\item la génération des fichiers stub java nécessaires pour un appel callback 
\item la génération à partir de l'ast CIdl.file du fichier .ml
\item la génération à partir du CIdl.file du fichier .mli
\end{itemize}
Ces différentes étapes seront présentées plus en profondeur.

\section{BNF}
\begin{multicols}{2}
\begin{idl}
file ::= package [package]*
  	| decl [decl]*
 
package	::= package qname ; decl [decl]*
decl ::= class
  	| interface
 
class ::= [ [attributes] ] [abstract] class name
  	  [ extends qname ]
  	  [ implements qname [, qname]* ]
  	  { [class_elt ;]* }
class_elt ::= [ [attributes] ] [static] [final] type name
  	| [ [attributes] ] [static] [abstract] type name ([args])
  	| [attributes] <init> ([args])
 
interface ::= [ [attributes] ] interface name
  	      [ extends qname [, qname]* ]
  	      { [interface_elt ;]* }
interface_elt ::= 
      [ [attributes] ] type name
      | [ [attributes] ] type name ([args])
 
args ::= arg [, arg]*
arg ::= [ [attributes] ] type [name]
 
attributes ::= 	attribute [, attribute]*
attribute ::= name ident
  	| callback
  	| array
 
type ::= basetype
  	| object
  	| basetype [ ]
basetype ::= void
  	| boolean
  	| byte
  	| char
  	| short
  	| int
  	| long
  	| float
  	| double
  	| string
object := qname
qname ::= name [. name]*
name ::= ident
\end{idl}
\end{multicols}

\section{lexing parsing}
La première phase est la phase d'analyse lexicale et syntaxique,
séparant l'idl en lexèmes et construisant l'AST, défini par Idl.file,
dont voici la structure :

\ 
\newline
\section{check}

Vient ensuite une phase, prenant l'AST obtenue par la
phase précédente, construisant une liste de CIdl.clazz, structurant
chaque classe ou interface déninie dans l'idl. 
Le module Cidl définit l'AST allant être manipulé dans les passes de
génération de code.

\section{génération stub\_file}
//TODO
\section{génération .ml}

La génération de ce code se fait en plusieurs passes sur l'ast obtenu
après ces précédents phases, le CIdl.file.

\textbf{Type jni}
\emph{MlClass.make\_jni\_type}

\textbf{Class type}
\emph{MlClass.make\_class\_type}

\textbf{Cast JNI}
\emph{MlClass.make\_jniupcast}
\emph{MlClass.make\_jnidowncast}

\textbf{Fonction d'allocation}
\emph{MlClass.make\_alloc}
\emph{MlClass.make\_alloc\_stub}

\textbf{Capsule / souche}
\emph{MlClass.make\_wrapper}

\textbf{Downcast utilisateur}
\emph{MlClass.make\_downcast}
\emph{MlClass.make\_instance\_of}

\textbf{Tableaux}
\emph{MlClass.make\_array}

\textbf{Fonction d'initialisation}
\emph{MlClass.make\_fun}

\textbf{Classe de construction}
\emph{MlClass.make\_class}



\textbf{fonctions / methodes static}
\emph{MlClass.make\_static}





\section{génération .mli}
 














\newpage
\section*{Annexe}
\subsection*{Module Idl}
\begin{multicols}{2}
\begin{OCaml}
(**  module Idl  *)

type ident = {
    id_location: Loc.t;
    id_desc: string 
  }
type qident = {
    qid_location: Loc.t;
    qid_package: string list;
    qid_name: ident;
  }
type type_desc = 
    Ivoid  
  | Iboolean
  | Ibyte
  | Ishort
  | Icamlint
  | Iint
  | Ilong
  | Ifloat
  | Idouble
  | Ichar
  | Istring
  | Itop
  | Iarray of typ
  | Iobject of qident
and typ = {
    t_location: Loc.t;
    t_desc: type_desc;
  }
type modifier_desc = 
  | Ifinal 
  | Istatic 
  | Iabstract
and modifier = {
    mo_location: Loc.t; 
    mo_desc: modifier_desc;
}
type ann_desc =
  | Iname of ident
  | Icallback
  | Icamlarray
and annotation = {
    an_location: Loc.t; 
    an_desc: ann_desc;
}
type arg = {
    arg_location: Loc.t; 
    arg_annot: annotation list;
    arg_type: typ
}   
type init = {
    i_location: Loc.t;
    i_annot: annotation list; 
    i_args: arg list;
}   
type field = {
    f_location: Loc.t;
    f_annot: annotation list; 
    f_modifiers: modifier list;
    f_name: ident;
    f_type: typ
}
type mmethod = { 
    m_location: Loc.t;
    m_annot: annotation list;
    m_modifiers: modifier list;
    m_name: ident;
    m_return_type: typ;
    m_args: arg list
}
type content = 
    | Method of mmethod 
    | Field of field
type def = {
    d_location: Loc.t;
    d_super: qident option;
    d_implements: qident list;
    d_annot: annotation list;
    d_interface: bool;
    d_modifiers: modifier list;
    d_name: ident;
    d_inits: init list;
    d_contents: content list;
}
type package = {
    p_name: string list;
    p_defs: def list;
}   
type file = package list
 
\end{OCaml}
\end{multicols}
\subsection*{Module CIdl}
\begin{OCaml}
(**  module CIdl  *)
type typ =
  | Cvoid
  | Cboolean (** boolean -> bool *)
  | Cchar (** char -> char *)
  | Cbyte (** byte -> int *)
  | Cshort (** short -> int *)
  | Ccamlint (** int -> int<31> *)
  | Cint (** int -> int32 *)
  | Clong (** long -> int64 *)
  | Cfloat (** float -> float *)
  | Cdouble (** double -> float *)
  | Ccallback of Ident.clazz
  | Cobject of object_type (** object -> ... *)
and object_type = 
  | Cname of Ident.clazz (** ... -> object *)
  | Cstring (** ... -> string *)
  | Cjavaarray of typ (** ... -> t jArray *) 
  | Carray of typ (** ... -> t array *) 
  | Ctop

type clazz = {
    cc_abstract: bool;
    cc_callback: bool;
    cc_ident: Ident.clazz;
    cc_extend: clazz option; (* None = top *)
    cc_implements: clazz list;
    cc_all_inherited: clazz list; (* tout jusque top ... (et avec les interfaces) sauf elle-meme. *)
    cc_inits: init list;
    cc_methods: mmethod list; (* methodes + champs *)
    cc_public_methods: mmethod list; (* methodes declarees + celles heritees *)
    cc_static_methods: mmethod list; 
  }
and mmethod_desc = 
  | Cmethod of bool * typ * typ list (* abstract, rtype, args *)
  | Cget of typ
  | Cset of typ
and mmethod = {
    cm_class: Ident.clazz;
    cm_ident: Ident.mmethod; 
    cm_desc: mmethod_desc;
  }         
and init = {
    cmi_ident: Ident.mmethod;
    cmi_class: Ident.clazz;
    cmi_args: typ list;
  }
type file = clazz list
\end{OCaml}
\subsection*{module Ident}
\begin{OCaml}
(* module Ident  *)
(* le type des identifiants de classe de l'IDL *)
type clazz = {
    ic_id: int;
    ic_interface: bool;
    ic_java_package: string list;
    ic_java_name: string;
    ic_ml_name: string;
    ic_ml_name_location: Loc.t;
    ic_ml_name_kind: ml_kind;
  }
type mmethod = {
    im_java_name: string;
    im_ml_id: int; (** entier unique pour une nom ml *)
    im_ml_name: string;
    im_ml_name_location:Loc.t;
    im_ml_name_kind: ml_kind;
  }
\end{OCaml}

\subsection*{idl\_camlgen.make ast}
\begin{OCaml}
(** Fonction idl_camlgen.make *)

  let str_list = [] in
  (** Type jni *)
  let str_list = (MlClass.make_jni_type c_file) :: str_list in
  (** Class type *)
  let class_type = MlClass.make_class_type ~callback:false c_file in
  let str_list = match class_type with 
  | [] -> str_list 
  | list -> <:str_item< class type $MlGen.make_rec_class_type class_type$ >> :: str_list in
  let class_type = MlClass.make_class_type ~callback:true c_file in
  let str_list = match class_type with 
  | [] -> str_list 
  | list -> <:str_item< class type $MlGen.make_rec_class_type class_type$ >> :: str_list in
  (** cast JNI *)
  let str_list = (MlClass.make_jniupcast c_file) :: str_list in
  let str_list = (MlClass.make_jnidowncast c_file):: str_list in 
  (** fonction d'allocations *)
  let str_list = (MlClass.make_alloc c_file) :: str_list in
  let str_list = (MlClass.make_alloc_stub c_file) :: str_list in
  (** capsule/souche *)
  let wrapper = [] in
  let wrapper = List.append (MlClass.make_wrapper ~callback:true c_file) wrapper in
  let wrapper = List.append (MlClass.make_wrapper ~callback:false c_file) wrapper in
  let str_list = match wrapper with 
    | [] -> str_list 
    | _ ->
        let list = MlGen.make_rec_class_expr wrapper in
        <:str_item< class $list$ >> :: str_list
  in
  (** downcast 'utilisateur' *)
  let str_list = (MlClass.make_downcast c_file) :: str_list in
  let str_list = (MlClass.make_instance_of c_file) :: str_list in
  (** Tableaux *)
  let str_list = (MlClass.make_array c_file) :: str_list in
  (** fonction d'initialisation *)
  let str_list = (MlInit.make_fun ~callback:false c_file) :: str_list in
  let str_list = (MlInit.make_fun ~callback:true c_file) :: str_list in
  (** classe de construction *)
  let str_list = (MlInit.make_class ~callback:false c_file) :: str_list in
  let str_list = (MlInit.make_class ~callback:true c_file) :: str_list in
  (** fonctions / mehodes static *)
  let str_list = (MlMethod.make_static c_file) :: str_list in
  List.rev str_list
\end{OCaml}

\end{document}
