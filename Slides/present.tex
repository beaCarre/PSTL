
\documentclass[xcolor={table,dvipsnames}]{beamer}

\usetheme{Warsaw}

\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{hyperref}


\usepackage{graphicx}

\usepackage{tikz}
\usetikzlibrary{arrows}

\pdfcompresslevel0

\newcommand{\camljava}{{\tt{camljava}}}

\usepackage{listings}
\usepackage{color}
\definecolor{darkgray}{rgb}{.5,.2,.2}

\usepackage[table]{xcolor}

\lstdefinelanguage{idlgrammar}{
  morekeywords={package,abstract,extends,class,implements,static,final,<ini>,interface,callback,array,[,],{,},
    name ,void,boolean,byte,char,short,int,long,float,double,string},
  alsoletter=[]{},
}
\lstnewenvironment{idlEx}
                  {\lstset{
                      language=idlgrammar,
                      breaklines=true,
                      showstringspaces=false,
                      commentstyle=\color{red},
                      stringstyle=\color{darkgray},
                      identifierstyle=\ttfamily\textit,
                      keywordstyle=\color{blue},
                      basicstyle=\tiny,
                      escapeinside={/*}{*/},
                      frame=single,
                      %xleftmargin=0.08\textwidth
                    }
                  }
                  {}

\lstnewenvironment{OCamlEx}
                  {\lstset{
                      language=[Objective]Caml,
                      breaklines=true,
                      showstringspaces=false,
                      commentstyle=\color{red},
                      stringstyle=\color{darkgray},
                      identifierstyle=\ttfamily,
                      keywordstyle=\color{blue},
                      basicstyle=\tiny,
                      escapeinside={/*}{*/},
                      frame=single,
                      %xleftmargin=0.08\textwidth
                    }
                  }
                  {}

\lstnewenvironment{javaEx}
                  {\lstset{
                      language=Java,             
                      breaklines=true,
                      showstringspaces=false,
                      commentstyle=\color{red},
                      stringstyle=\color{darkgray},
                      identifierstyle=\ttfamily\textit,
                      keywordstyle=\color{purple},
                      basicstyle=\tiny,
                      escapeinside={/*}{*/},
                      frame=double,
                      %xleftmargin=0.08\textwidth
                    }
                  }
                  {}


\addtobeamertemplate{footline}{\hfill\insertframenumber/\inserttotalframenumber

\hspace{10em}\\}

\usepackage{listings}

\title{Interopérabilité entre OCaml et Java }
\author{Béatrice Carré}
\date{\today}

% slides number
\defbeamertemplate*{footline}{shadow theme}
{%
  \leavevmode%
  \hbox{
    \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.5ex,dp=1.125ex,leftskip=.3cm plus1fil,rightskip=.3cm]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertframenumber\,/\,\inserttotalframenumber\hfill\insertshortauthor
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.5ex,dp=1.125ex,leftskip=.3cm,rightskip=.3cm plus1fil]{}%
    \usebeamerfont{title in head/foot}\insertshorttitle%
  \end{beamercolorbox}}%
  \vskip0pt%
}

\beamertemplatenavigationsymbolsempty


\begin{document}

\maketitle




\begin{frame}{Objectif}
\begin{definition}
L'\alert{interop\'erabilit\'e entre deux langages} est la 
capacité d'un programme écrit dans un certain langage d'utiliser un
programme dans un autre langage.
\end{definition}
\begin{itemize}
\item Intérêt :

Tirer parti des spécificités de chaque langage

\item Caractéristiques d'une interopérabilité efficace :
\begin{itemize}
\item accès simple ou implicite à l'autre langage
\item gestion mémoire et des exceptions
\item bonne gestion des caractéristiques différentes
\end{itemize}
\end{itemize}
\end{frame}



\begin{frame}{Comparaison des deux mondes}
L'interopérabilité se fait sur le modèle objet de chacun, dont voici les caractéristiques qui diffèrent :

\bigskip
\begin{tabular}{|l|c|c|c|c|}
  \hline
  \emph{caractéristiques} & \emph{Java} & \emph{OCaml} \\
  \hline
  accès champs & selon la visibilité & via appels de méthode\\\hline
  var./méth. statiques & \checkmark & fonct./décl. globales\\\hline
  typage dynamique & \checkmark &  $\times$  \\\hline
  surcharge & \checkmark & $\times$ \\\hline
  héritage multiple & pour les interfaces & \checkmark\\
  \hline
\end{tabular}

\bigskip

$\Rightarrow$ Il faut réduire les possibilités d'un outil à l'intersection des deux mondes
\end{frame}



\begin{frame}{O'Jacaré : schéma global }

\begin{definition}
Un \alert{IDL} (Langage de définition d'Interface) définit une interface entre les deux langages, qui va permettre de les faire communiquer.
\end{definition}

O'Jacaré génère les classes encapsulantes à partir d'un IDL dans lequel sont décrites les classes qu'on veut manipuler.
\medskip
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.6]{schemaOjacare.png}
  \caption{La génération de code d'O'Jacaré}
\end{figure}

\end{frame}


\begin{frame}{O'Jacaré : schéma global (2) }
  \begin{definition}
    La \alert{classe encapsulante} générée à partir de l'IDL contient une référence sur un objet Java et permet à l'utilisateur de faire les appels sur celui-ci.
  \end{definition}
La bibliothèque \camljava \ gère la communication OCaml-Java :
\begin{itemize}
\item Recherche des classes par nom et des méthodes par signature
\item La conversion des types de base est assurée
\end{itemize}
\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.8]{schemaCamljava2.png}
\end{figure}

\end{frame}





\begin{frame}[fragile]{La classe Point (Java)}
%mise en page TODO

\bigskip

\begin{javaEx} 
  package mypack;
  public class Point {
    int x;
    int y;
    public Point() { 
      this.x = 0;
      this.y = 0;
    }
    public Point(int x,int y) {
      this.x = x;
      this.y = y;
    }
    public void moveto(int x,int y){
      this.x = x;
      this.y = y;
    }
    public String toString() {
      return "("+x+","+y+")";
    }
    public double distance() {
      return Math.sqrt (this.x*this.x+this.y*this.y);
    }
    public boolean eq(Point p) {
      return this.x == p.x  && this.y == p.y;
    }
  }
\end{javaEx}

\end{frame}





\begin{frame}[fragile]{O'Jacaré : définition de l'IDL}
  IDL : point.idl
\begin{idlEx} 
package mypack;

class Point {
  int x;
  int y; 
  [name default_point] <init> ();
  [name point] <init> (int,int);
  void moveto(int,int);
  string toString();
  boolean eq(Point);
}
\end{idlEx}

Utilisation : main.ml
\begin{OCamlEx}
  open Point

  let p = new default_point () in
  let p2 = new point 1 1 in
  p#moveto 4 3;
  p#display ();
  print_string (if (p#eq p2) then "true" else "false")
\end{OCamlEx}
\end{frame}




\begin{frame}{OCaml-Java : schéma global}
\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.8]{schemaOCamlJava.png}
\end{figure}
Compilation vers du bytecode Java

$\Rightarrow$ un seul runtime
\begin{itemize}
\item Pas de problème de gestion mémoire, 
\item ni de communication dynamique
\end{itemize}
\end{frame}





\begin{frame}[fragile]{OCaml-Java : l'accès au monde Java}
\begin{OCamlEx}
make : 'a java_constructor -> 'a 
call : 'a java_method -> 'a 
get : 'a java_field_get -> 'a 
set : 'a java_field_set -> 'a 
is_null : 'a java_instance -> bool 
instanceof : 'a java_type -> 'b java_instance -> bool
cast : 'a java_type -> 'b java_instance -> 'a
\end{OCamlEx}

Accès aux bibliothèques Java et à du code utilisateur grâce à ce module.

\begin{OCamlEx}
let color = JavaString.of_string "bleu"
and x = Int32.of_int 1
and y = Int32.of_int 2 in
let p = Java.make "mypack.ColoredPoint(int,int,java.lang.String)" s y color 
in
   Java.call "mypack.Point.eq(mypack.Point):boolean" p p2
\end{OCamlEx}


\end{frame}


\begin{frame}{Fusion des deux approches}

\begin{tabular}{|c|c@{\,\vrule width 6pt\,}c|}
  \hline
   \cellcolor[gray]{0.6}\emph{O'Jacaré+}\camljava & \cellcolor[gray]{0.6}\emph{OCaml-Java}& \cellcolor[gray]{0.6} \emph{O'Jacaré+OCaml-Java}\\
  \hline\hline
 \cellcolor[gray]{0.9} appels transparents & via module Java & \cellcolor[gray]{0.9}appels transparents\\
\hline
  2 runtime &\cellcolor[gray]{0.9} 1 runtime&\cellcolor[gray]{0.9} 1 runtime \\
\hline
\end{tabular}
\begin{figure}[h]
  \centering
  \includegraphics[scale=1]{schema1.png}
\end{figure}

\end{frame}



\begin{frame}{Adaptation d'Ojacaré}

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.30]{typesOCamlJava.png}
  \caption{Les types dans OCamlJava}
\end{figure}

\end{frame}

\begin{frame}{Comparaison de génération}
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.35]{exemple.png}
  \caption{La génération du constructeur de Point}
\end{figure}
\end{frame}


\begin{frame}{Conclusion}

Ce nouvel outil a apporté des nouvelles possibilités d'un côté,
avec une simplicité d'utilisation :
\begin{itemize}
\item Accès simple à l'API Java
\item Accès utilisateur transparent grâce aux classes encapsulantes
\item 1 seul runtime -> Gestion mémoire simplifiée et sûre
\item Code généré simplifié ($\sim$ 5 fois moins)
\item 
\end{itemize}

\end{frame}

%% \begin{frame}{Bibliographie}
  
%%   \begin{thebibliography}{9}
%%   \bibitem{amato2013localizing}
%%     Amato, Gianluca and Scozzari, Francesca,
%%     \emph{Localizing widening and narrowing}.
%%     Static Analysis, Springer.
%%     pages 25--42,
%%     2013.

%%   \bibitem{halbwachs2012decreasing}
%%     Halbwachs, Nicolas and Henry, Julien,
%%     \emph{When the decreasing sequence fails}.
%%     Static Analysis, Springer.
%%     pages 198--213,
%%     2012.
%%   \end{thebibliography}

%% \end{frame}

\end{document}

